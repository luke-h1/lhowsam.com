var StaticKitReact = (function (exports, React) {
  'use strict';

  var React__default = 'default' in React ? React['default'] : React;

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  /**
   * @this {Promise}
   */
  function finallyConstructor(callback) {
    var constructor = this.constructor;
    return this.then(
      function(value) {
        // @ts-ignore
        return constructor.resolve(callback()).then(function() {
          return value;
        });
      },
      function(reason) {
        // @ts-ignore
        return constructor.resolve(callback()).then(function() {
          // @ts-ignore
          return constructor.reject(reason);
        });
      }
    );
  }

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function isArray(x) {
    return Boolean(x && typeof x.length !== 'undefined');
  }

  function noop() {}

  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function() {
      fn.apply(thisArg, arguments);
    };
  }

  /**
   * @constructor
   * @param {Function} fn
   */
  function Promise(fn) {
    if (!(this instanceof Promise))
      throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    /** @type {!number} */
    this._state = 0;
    /** @type {!boolean} */
    this._handled = false;
    /** @type {Promise|undefined} */
    this._value = undefined;
    /** @type {!Array<!Function>} */
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function() {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self)
        throw new TypeError('A promise cannot be resolved with itself.');
      if (
        newValue &&
        (typeof newValue === 'object' || typeof newValue === 'function')
      ) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  /**
   * @constructor
   */
  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(
        function(value) {
          if (done) return;
          done = true;
          resolve(self, value);
        },
        function(reason) {
          if (done) return;
          done = true;
          reject(self, reason);
        }
      );
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function(onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function(onFulfilled, onRejected) {
    // @ts-ignore
    var prom = new this.constructor(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.prototype['finally'] = finallyConstructor;

  Promise.all = function(arr) {
    return new Promise(function(resolve, reject) {
      if (!isArray(arr)) {
        return reject(new TypeError('Promise.all accepts an array'));
      }

      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(
                val,
                function(val) {
                  res(i, val);
                },
                reject
              );
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function(value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function(resolve) {
      resolve(value);
    });
  };

  Promise.reject = function(value) {
    return new Promise(function(resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function(arr) {
    return new Promise(function(resolve, reject) {
      if (!isArray(arr)) {
        return reject(new TypeError('Promise.race accepts an array'));
      }

      for (var i = 0, len = arr.length; i < len; i++) {
        Promise.resolve(arr[i]).then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn =
    // @ts-ignore
    (typeof setImmediate === 'function' &&
      function(fn) {
        // @ts-ignore
        setImmediate(fn);
      }) ||
    function(fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var fetchBrowser = createCommonjsModule(function (module, exports) {
  (function (self) {

    function fetchPonyfill(options) {
      var Promise = options && options.Promise || self.Promise;
      var XMLHttpRequest = options && options.XMLHttpRequest || self.XMLHttpRequest;
      var global = self;

      return (function () {
        var self = Object.create(global, {
          fetch: {
            value: undefined,
            writable: true
          }
        });

        (function(self) {

          if (self.fetch) {
            return
          }

          var support = {
            searchParams: 'URLSearchParams' in self,
            iterable: 'Symbol' in self && 'iterator' in Symbol,
            blob: 'FileReader' in self && 'Blob' in self && (function() {
              try {
                new Blob();
                return true
              } catch(e) {
                return false
              }
            })(),
            formData: 'FormData' in self,
            arrayBuffer: 'ArrayBuffer' in self
          };

          if (support.arrayBuffer) {
            var viewClasses = [
              '[object Int8Array]',
              '[object Uint8Array]',
              '[object Uint8ClampedArray]',
              '[object Int16Array]',
              '[object Uint16Array]',
              '[object Int32Array]',
              '[object Uint32Array]',
              '[object Float32Array]',
              '[object Float64Array]'
            ];

            var isDataView = function(obj) {
              return obj && DataView.prototype.isPrototypeOf(obj)
            };

            var isArrayBufferView = ArrayBuffer.isView || function(obj) {
              return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
            };
          }

          function normalizeName(name) {
            if (typeof name !== 'string') {
              name = String(name);
            }
            if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
              throw new TypeError('Invalid character in header field name')
            }
            return name.toLowerCase()
          }

          function normalizeValue(value) {
            if (typeof value !== 'string') {
              value = String(value);
            }
            return value
          }

          // Build a destructive iterator for the value list
          function iteratorFor(items) {
            var iterator = {
              next: function() {
                var value = items.shift();
                return {done: value === undefined, value: value}
              }
            };

            if (support.iterable) {
              iterator[Symbol.iterator] = function() {
                return iterator
              };
            }

            return iterator
          }

          function Headers(headers) {
            this.map = {};

            if (headers instanceof Headers) {
              headers.forEach(function(value, name) {
                this.append(name, value);
              }, this);
            } else if (Array.isArray(headers)) {
              headers.forEach(function(header) {
                this.append(header[0], header[1]);
              }, this);
            } else if (headers) {
              Object.getOwnPropertyNames(headers).forEach(function(name) {
                this.append(name, headers[name]);
              }, this);
            }
          }

          Headers.prototype.append = function(name, value) {
            name = normalizeName(name);
            value = normalizeValue(value);
            var oldValue = this.map[name];
            this.map[name] = oldValue ? oldValue+','+value : value;
          };

          Headers.prototype['delete'] = function(name) {
            delete this.map[normalizeName(name)];
          };

          Headers.prototype.get = function(name) {
            name = normalizeName(name);
            return this.has(name) ? this.map[name] : null
          };

          Headers.prototype.has = function(name) {
            return this.map.hasOwnProperty(normalizeName(name))
          };

          Headers.prototype.set = function(name, value) {
            this.map[normalizeName(name)] = normalizeValue(value);
          };

          Headers.prototype.forEach = function(callback, thisArg) {
            for (var name in this.map) {
              if (this.map.hasOwnProperty(name)) {
                callback.call(thisArg, this.map[name], name, this);
              }
            }
          };

          Headers.prototype.keys = function() {
            var items = [];
            this.forEach(function(value, name) { items.push(name); });
            return iteratorFor(items)
          };

          Headers.prototype.values = function() {
            var items = [];
            this.forEach(function(value) { items.push(value); });
            return iteratorFor(items)
          };

          Headers.prototype.entries = function() {
            var items = [];
            this.forEach(function(value, name) { items.push([name, value]); });
            return iteratorFor(items)
          };

          if (support.iterable) {
            Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
          }

          function consumed(body) {
            if (body.bodyUsed) {
              return Promise.reject(new TypeError('Already read'))
            }
            body.bodyUsed = true;
          }

          function fileReaderReady(reader) {
            return new Promise(function(resolve, reject) {
              reader.onload = function() {
                resolve(reader.result);
              };
              reader.onerror = function() {
                reject(reader.error);
              };
            })
          }

          function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsArrayBuffer(blob);
            return promise
          }

          function readBlobAsText(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsText(blob);
            return promise
          }

          function readArrayBufferAsText(buf) {
            var view = new Uint8Array(buf);
            var chars = new Array(view.length);

            for (var i = 0; i < view.length; i++) {
              chars[i] = String.fromCharCode(view[i]);
            }
            return chars.join('')
          }

          function bufferClone(buf) {
            if (buf.slice) {
              return buf.slice(0)
            } else {
              var view = new Uint8Array(buf.byteLength);
              view.set(new Uint8Array(buf));
              return view.buffer
            }
          }

          function Body() {
            this.bodyUsed = false;

            this._initBody = function(body) {
              this._bodyInit = body;
              if (!body) {
                this._bodyText = '';
              } else if (typeof body === 'string') {
                this._bodyText = body;
              } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body;
              } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body;
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this._bodyText = body.toString();
              } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                this._bodyArrayBuffer = bufferClone(body.buffer);
                // IE 10-11 can't handle a DataView body.
                this._bodyInit = new Blob([this._bodyArrayBuffer]);
              } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                this._bodyArrayBuffer = bufferClone(body);
              } else {
                throw new Error('unsupported BodyInit type')
              }

              if (!this.headers.get('content-type')) {
                if (typeof body === 'string') {
                  this.headers.set('content-type', 'text/plain;charset=UTF-8');
                } else if (this._bodyBlob && this._bodyBlob.type) {
                  this.headers.set('content-type', this._bodyBlob.type);
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                }
              }
            };

            if (support.blob) {
              this.blob = function() {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected
                }

                if (this._bodyBlob) {
                  return Promise.resolve(this._bodyBlob)
                } else if (this._bodyArrayBuffer) {
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]))
                } else if (this._bodyFormData) {
                  throw new Error('could not read FormData body as blob')
                } else {
                  return Promise.resolve(new Blob([this._bodyText]))
                }
              };

              this.arrayBuffer = function() {
                if (this._bodyArrayBuffer) {
                  return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
                } else {
                  return this.blob().then(readBlobAsArrayBuffer)
                }
              };
            }

            this.text = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected
              }

              if (this._bodyBlob) {
                return readBlobAsText(this._bodyBlob)
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
              } else if (this._bodyFormData) {
                throw new Error('could not read FormData body as text')
              } else {
                return Promise.resolve(this._bodyText)
              }
            };

            if (support.formData) {
              this.formData = function() {
                return this.text().then(decode)
              };
            }

            this.json = function() {
              return this.text().then(JSON.parse)
            };

            return this
          }

          // HTTP methods whose capitalization should be normalized
          var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

          function normalizeMethod(method) {
            var upcased = method.toUpperCase();
            return (methods.indexOf(upcased) > -1) ? upcased : method
          }

          function Request(input, options) {
            options = options || {};
            var body = options.body;

            if (input instanceof Request) {
              if (input.bodyUsed) {
                throw new TypeError('Already read')
              }
              this.url = input.url;
              this.credentials = input.credentials;
              if (!options.headers) {
                this.headers = new Headers(input.headers);
              }
              this.method = input.method;
              this.mode = input.mode;
              if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.bodyUsed = true;
              }
            } else {
              this.url = String(input);
            }

            this.credentials = options.credentials || this.credentials || 'omit';
            if (options.headers || !this.headers) {
              this.headers = new Headers(options.headers);
            }
            this.method = normalizeMethod(options.method || this.method || 'GET');
            this.mode = options.mode || this.mode || null;
            this.referrer = null;

            if ((this.method === 'GET' || this.method === 'HEAD') && body) {
              throw new TypeError('Body not allowed for GET or HEAD requests')
            }
            this._initBody(body);
          }

          Request.prototype.clone = function() {
            return new Request(this, { body: this._bodyInit })
          };

          function decode(body) {
            var form = new FormData();
            body.trim().split('&').forEach(function(bytes) {
              if (bytes) {
                var split = bytes.split('=');
                var name = split.shift().replace(/\+/g, ' ');
                var value = split.join('=').replace(/\+/g, ' ');
                form.append(decodeURIComponent(name), decodeURIComponent(value));
              }
            });
            return form
          }

          function parseHeaders(rawHeaders) {
            var headers = new Headers();
            // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
            // https://tools.ietf.org/html/rfc7230#section-3.2
            var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
            preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
              var parts = line.split(':');
              var key = parts.shift().trim();
              if (key) {
                var value = parts.join(':').trim();
                headers.append(key, value);
              }
            });
            return headers
          }

          Body.call(Request.prototype);

          function Response(bodyInit, options) {
            if (!options) {
              options = {};
            }

            this.type = 'default';
            this.status = options.status === undefined ? 200 : options.status;
            this.ok = this.status >= 200 && this.status < 300;
            this.statusText = 'statusText' in options ? options.statusText : 'OK';
            this.headers = new Headers(options.headers);
            this.url = options.url || '';
            this._initBody(bodyInit);
          }

          Body.call(Response.prototype);

          Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new Headers(this.headers),
              url: this.url
            })
          };

          Response.error = function() {
            var response = new Response(null, {status: 0, statusText: ''});
            response.type = 'error';
            return response
          };

          var redirectStatuses = [301, 302, 303, 307, 308];

          Response.redirect = function(url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
              throw new RangeError('Invalid status code')
            }

            return new Response(null, {status: status, headers: {location: url}})
          };

          self.Headers = Headers;
          self.Request = Request;
          self.Response = Response;

          self.fetch = function(input, init) {
            return new Promise(function(resolve, reject) {
              var request = new Request(input, init);
              var xhr = new XMLHttpRequest();

              xhr.onload = function() {
                var options = {
                  status: xhr.status,
                  statusText: xhr.statusText,
                  headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                };
                options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                var body = 'response' in xhr ? xhr.response : xhr.responseText;
                resolve(new Response(body, options));
              };

              xhr.onerror = function() {
                reject(new TypeError('Network request failed'));
              };

              xhr.ontimeout = function() {
                reject(new TypeError('Network request failed'));
              };

              xhr.open(request.method, request.url, true);

              if (request.credentials === 'include') {
                xhr.withCredentials = true;
              } else if (request.credentials === 'omit') {
                xhr.withCredentials = false;
              }

              if ('responseType' in xhr && support.blob) {
                xhr.responseType = 'blob';
              }

              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });

              xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
            })
          };
          self.fetch.polyfill = true;
        })(typeof self !== 'undefined' ? self : this);


        return {
          fetch: self.fetch,
          Headers: self.Headers,
          Request: self.Request,
          Response: self.Response
        };
      }());
    }

    {
      module.exports = fetchPonyfill;
    }
  }(typeof self !== 'undefined' ? self : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : commonjsGlobal));
  });

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _slicedToArray$1(arr, i) {
    return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _nonIterableRest$1();
  }

  function _arrayWithHoles$1(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit$1(arr, i) {
    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
      return;
    }

    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
  function btoa(string) {
    string = String(string);
    var bitmap,
        a,
        b,
        c,
        result = '',
        i = 0,
        rest = string.length % 3; // To determine the final padding

    for (; i < string.length;) {
      if ((a = string.charCodeAt(i++)) > 255 || (b = string.charCodeAt(i++)) > 255 || (c = string.charCodeAt(i++)) > 255) throw new TypeError("Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.");
      bitmap = a << 16 | b << 8 | c;
      result += b64.charAt(bitmap >> 18 & 63) + b64.charAt(bitmap >> 12 & 63) + b64.charAt(bitmap >> 6 & 63) + b64.charAt(bitmap & 63);
    } // If there's need of padding, replace the last 'A's with equal signs


    return rest ? result.slice(0, rest - 3) + '==='.substring(rest) : result;
  }
  function atob(string) {
    // atob can work with strings with whitespaces, even inside the encoded part,
    // but only \t, \n, \f, \r and ' ', which can be stripped.
    string = String(string).replace(/[\t\n\f\r ]+/g, '');
    if (!b64re.test(string)) throw new TypeError("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded."); // Adding the padding if missing, for semplicity

    string += '=='.slice(2 - (string.length & 3));
    var bitmap,
        result = '',
        r1,
        r2,
        i = 0;

    for (; i < string.length;) {
      bitmap = b64.indexOf(string.charAt(i++)) << 18 | b64.indexOf(string.charAt(i++)) << 12 | (r1 = b64.indexOf(string.charAt(i++))) << 6 | (r2 = b64.indexOf(string.charAt(i++)));
      result += r1 === 64 ? String.fromCharCode(bitmap >> 16 & 255) : r2 === 64 ? String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255) : String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255, bitmap & 255);
    }

    return result;
  }

  var version = "2.5.1";

  /**
   * Base-64 encodes a (JSON-castable) object.
   *
   * @param obj - The object to encode.
   */

  var encode64 = function encode64(obj) {
    return btoa(JSON.stringify(obj));
  };
  /**
   * Appends a key-value pair to a target.
   *
   * @param target - An object or FormData instance to mutate.
   * @param key - The key to append.
   * @param value - The value to append.
   */

  var append = function append(target, key, value) {
    if (target instanceof FormData) {
      target.append(key, value);
    } else {
      target[key] = value;
    }
  };
  /**
   * Converts a snake case string to camel case.
   *
   * @param str - A string to convert to camel case.
   */

  var toCamel = function toCamel(str) {
    return str.replace(/([-_][a-z])/gi, function ($1) {
      return $1.toUpperCase().replace('-', '').replace('_', '');
    });
  };
  /**
   * Converts the top-level keys of an object to camel case.
   * This function returns a new object (instead of mutating in place).
   *
   * @param obj - An object with string keys.
   */

  var camelizeTopKeys = function camelizeTopKeys(obj) {
    var newObject = {};

    for (var _i = 0, _Object$entries = Object.entries(obj); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray$1(_Object$entries[_i], 2),
          _key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      newObject[toCamel(_key)] = value;
    }

    return newObject;
  };
  /**
   * Generates a client header.
   *
   * @param givenLabel
   */

  var clientHeader = function clientHeader(givenLabel) {
    var label = "@statickit/core@".concat(version);
    if (!givenLabel) return label;
    return "".concat(givenLabel, " ").concat(label);
  };
  /**
   * The current timestamp.
   */

  var now = function now() {
    // @ts-ignore
    return 1 * new Date();
  };

  var webdriver = function webdriver() {
    return navigator.webdriver || !!document.documentElement.getAttribute(atob('d2ViZHJpdmVy')) || // @ts-ignore
    !!window.callPhantom || // @ts-ignore
    !!window._phantom;
  };

  var Session =
  /*#__PURE__*/
  function () {
    function Session() {
      _classCallCheck(this, Session);

      this.loadedAt = now();
      this.webdriver = webdriver();
    }

    _createClass(Session, [{
      key: "teardown",
      value: function teardown() {}
    }, {
      key: "data",
      value: function data() {
        return {
          loadedAt: this.loadedAt,
          webdriver: this.webdriver
        };
      }
    }]);

    return Session;
  }();

  var StaticKit =
  /*#__PURE__*/
  function () {
    function StaticKit(config) {
      _classCallCheck(this, StaticKit);

      this.site = config.site;
      if (typeof window !== 'undefined') this.startBrowserSession();
    }
    /**
     * Starts a browser session.
     */


    _createClass(StaticKit, [{
      key: "startBrowserSession",
      value: function startBrowserSession() {
        if (!this.session) {
          this.session = new Session();
        }
      }
      /**
       * Teardown the client session.
       */

    }, {
      key: "teardown",
      value: function teardown() {
        if (this.session) this.session.teardown();
      }
      /**
       * Submit a form.
       *
       * @param key - The form key.
       * @param data - An object or FormData instance containing submission data.
       * @param args - An object of form submission data.
       */

    }, {
      key: "submitForm",
      value: function submitForm(key, data) {
        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var endpoint = opts.endpoint || 'https://api.statickit.com';
        var fetchImpl = opts.fetchImpl || fetchBrowser({
          Promise: Promise
        }).fetch;
        var url = "".concat(endpoint, "/j/sites/").concat(this.site, "/forms/").concat(key, "/submissions");

        var serializeBody = function serializeBody(data) {
          if (data instanceof FormData) return data;
          return JSON.stringify(data);
        };

        if (this.session) {
          append(data, '_t', encode64(this.session.data()));
        }

        var headers = {
          'StaticKit-Client': clientHeader(opts.clientName)
        };

        if (!(data instanceof FormData)) {
          headers['Content-Type'] = 'application/json';
        }

        var request = {
          method: 'POST',
          mode: 'cors',
          body: serializeBody(data),
          headers: headers
        };
        return fetchImpl(url, request).then(function (response) {
          return response.json().then(function (body) {
            return {
              body: body,
              response: response
            };
          });
        });
      }
      /**
       * Invoke a function.
       *
       * @param name - The function name.
       * @param args - An object of function arguments.
       * @param opts - An object of options.
       */

    }, {
      key: "invokeFunction",
      value: function invokeFunction(name, args) {
        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var endpoint = opts.endpoint || 'https://api.statickit.com';
        var fetchImpl = opts.fetchImpl || fetchBrowser({
          Promise: Promise
        }).fetch;
        var url = "".concat(endpoint, "/j/sites/").concat(this.site, "/functions/").concat(name, "/invoke");
        var headers = {
          'StaticKit-Client': clientHeader(opts.clientName),
          'Content-Type': 'application/json'
        };
        var session = this.session ? encode64(this.session.data()) : null;
        var request = {
          method: 'POST',
          mode: 'cors',
          body: JSON.stringify({
            args: args,
            session: session
          }),
          headers: headers
        };
        return fetchImpl(url, request).then(function (response) {
          return response.json().then(function (body) {
            return camelizeTopKeys(body);
          });
        });
      }
    }]);

    return StaticKit;
  }();
  /**
   * Constructs the client object.
   */

  var createClient = function createClient(config) {
    return new StaticKit(config);
  };

  var StaticKitContext = React__default.createContext({
    client: undefined
  });
  StaticKitContext.displayName = 'StaticKit';
  var StaticKitProvider = function StaticKitProvider(props) {
    if (!props.site) {
      throw new Error('site is required');
    }

    var _useState = React.useState(function () {
      return createClient({
        site: props.site
      });
    }),
        _useState2 = _slicedToArray(_useState, 1),
        client = _useState2[0];

    React.useEffect(function () {
      client.startBrowserSession();
      return function () {
        client.teardown();
      };
    }, []);
    return React__default.createElement(StaticKitContext.Provider, {
      value: {
        client: client
      }
    }, props.children);
  };
  function useStaticKit() {
    var _useContext = React.useContext(StaticKitContext),
        client = _useContext.client;

    return client;
  }

  var version$1 = "2.1.1";

  function useForm(formKey) {
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var _useState = React.useState(false),
        _useState2 = _slicedToArray(_useState, 2),
        submitting = _useState2[0],
        setSubmitting = _useState2[1];

    var _useState3 = React.useState(false),
        _useState4 = _slicedToArray(_useState3, 2),
        succeeded = _useState4[0],
        setSucceeded = _useState4[1];

    var _useState5 = React.useState([]),
        _useState6 = _slicedToArray(_useState5, 2),
        errors = _useState6[0],
        setErrors = _useState6[1];

    var globalClient = useStaticKit();
    var client = args.client || globalClient;

    if (!client) {
      throw new Error('You must provide a StaticKit client');
    }

    if (!formKey) {
      throw new Error('You must provide a form key (e.g. useForm("myForm")');
    }

    var debug = !!args.debug;
    var extraData = args.data;

    var handleSubmit = function handleSubmit(event) {
      event.preventDefault();
      var form = event.target;

      if (form.tagName != 'FORM') {
        throw new Error('submit was triggered for a non-form element');
      }

      var formData = new FormData(form); // Append extra data from config

      if (_typeof(extraData) === 'object') {
        for (var prop in extraData) {
          if (typeof extraData[prop] === 'function') {
            formData.append(prop, extraData[prop].call(null));
          } else {
            formData.append(prop, extraData[prop]);
          }
        }
      }

      setSubmitting(true);
      return client.submitForm(formKey, formData, {
        endpoint: args.endpoint,
        clientName: "@statickit/react@".concat(version$1)
      }).then(function (result) {
        switch (result.response.status) {
          case 200:
            if (debug) console.log('Form submitted', result);
            setSucceeded(true);
            setErrors([]);
            break;

          case 422:
            var body = result.body;
            var _errors = body.errors;
            if (debug) console.log('Validation error', result);
            setSucceeded(false);
            setErrors(_errors);
            break;

          default:
            if (debug) console.log('Unexpected error', result);
            setSucceeded(false);
            break;
        }

        return result;
      })["catch"](function (error) {
        if (debug) console.log('Unexpected error', error);
        setSucceeded(false);
        throw error;
      })["finally"](function () {
        setSubmitting(false);
      });
    };

    return [{
      submitting: submitting,
      succeeded: succeeded,
      errors: errors
    }, handleSubmit];
  }

  var ValidationError = function ValidationError(props) {
    var prefix = props.prefix,
        field = props.field,
        errors = props.errors,
        attrs = _objectWithoutProperties(props, ["prefix", "field", "errors"]);

    var error = (errors || []).find(function (error) {
      return error.field == field;
    });

    if (!error) {
      return null;
    }

    return React__default.createElement("div", attrs, prefix, " ", error.message);
  };

  exports.StaticKitProvider = StaticKitProvider;
  exports.ValidationError = ValidationError;
  exports.useForm = useForm;
  exports.useStaticKit = useStaticKit;

  return exports;

}({}, React));
